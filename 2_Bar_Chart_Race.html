<!DOCTYPE html>
<html>

<head>
    <title>Data Visualization</title>
    <script src="./resources/js/d3.min.js"></script>
</head>

<body>

    <svg width="1600" height="960" id="mainSvg" class="svgs"></svg>
    <script>
        const mainSvg = d3.select('.svgs')
        const mainWidth = +mainSvg.attr("width");
        const mainHeight = +mainSvg.attr("height");
        const margin = {
            top: 60,
            right: 120,
            bottom: 120,
            left: 60
        };
        const innerWidth = mainWidth - margin.left - margin.right;
        const innerHeight = mainHeight - margin.bottom - margin.top;

        //图表部分的尺寸
        const width = innerWidth;
        const height = innerHeight;

        const g = mainSvg.append("g")
            .attr("id", "mainGroup")
            .attr("width", width)
            .attr("height", height)
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        //变换停留时间
        const duration = 250;
        //显示bar的数量
        const n = 12;

        //名字的集合
        var names;
        //按日期对数据排序
        var dateValues;

        //
        const k = 10;

        //TODO
        var nameFrames;
        var prev, next;

        //tick
        var formatNumber;
        var tickFormat;

        const barSize = 48;

        //坐标比例尺
        const xScale = d3.scaleLinear([0, 1], [margin.left, width - margin.right]);
        const yScale = d3.scaleBand()
            .domain(d3.range(n + 1))
            .rangeRound([margin.top, margin.top + barSize * (n + 1 + 0.1)])
            .padding(0.1);

        

        d3.csv("./resources/data/box_office.csv").then(data =>{
            names = new Set(data.map(d => d["影片名"]));
            dateValues = Array.from(d3.rollup(data, ([d]) => d["单日票房(万)"], d => +d.date, d => d["影片名"]))
                .map(([date, data]) => [new Date(date), data])
                .sort(([a], [b]) => d3.ascending(a, b));

            nameFrames = d3.groups(keyframes.flatMap(([, data]) => data), d => d["影片名"]);
            prev = new Map(nameFrames.flatMap(([, data]) => d3.pairs(data, (a, b) => [b, a])));
            next = new Map(nameFrames.flatMap(([, data]) => d3.pairs(data)));

            formatNumber = d3.format(",d");
            tickFormat = undefined; // override as desired

            chart();
        })

        
        

        rank = function(value) {
            const data = Array.from(names, name => ({
                name,
                value: value(name)
            }));
            data.sort((a, b) => d3.descending(a.value, b.value));
            for (let i = 0; i < data.length; ++i)
                data[i].rank = Math.min(n, i);
            return data;
        }

        keyframes = function () {
            const keyframes = [];
            let ka, a, kb, b;
            for ([
                    [ka, a],
                    [kb, b]
                ] of d3.pairs(dateValues)) {
                for (let i = 0; i < k; ++i) {
                    const t = i / k;
                    keyframes.push([
                        new Date(ka * (1 - t) + kb * t),
                        rank(name => (a.get(name) || 0) * (1 - t) + (b.get(name) || 0) * t)
                    ]);
                }
            }
            keyframes.push([new Date(kb), rank(name => b.get(name) || 0)]);
            return keyframes;
        }

        bars = function(svg) {
            let bar = svg.append("g")
                .attr("fill-opacity", 0.6)
                .selectAll("rect");

            return ([date, data], transition) => bar = bar
                .data(data.slice(0, n), d => d["影片名"])
                .join(
                    enter => enter.append("rect")
                    .attr("fill", color)
                    .attr("height", yScale.bandwidth())
                    .attr("x", xScale(0))
                    .attr("y", d => yScale((prev.get(d) || d).rank))
                    .attr("width", d => xScale((prev.get(d) || d).value) - xScale(0)),
                    update => update,
                    exit => exit.transition(transition).remove()
                    .attr("y", d => yScale((next.get(d) || d).rank))
                    .attr("width", d => xScale((next.get(d) || d).value) - xScale(0))
                )
                .call(bar => bar.transition(transition)
                    .attr("y", d => yScale(d.rank))
                    .attr("width", d => xScale(d["单日票房(万)"]) - xScale(0)));
        }

        labels = function(svg) {
            let label = svg.append("g")
                .style("font", "bold 12px var(--sans-serif)")
                .style("font-variant-numeric", "tabular-nums")
                .attr("text-anchor", "end")
                .selectAll("text");

            return ([date, data], transition) => label = label
                .data(data.slice(0, n), d => d["影片名"])
                .join(
                    enter => enter.append("text")
                    .attr("transform", d => `translate(${xScale((prev.get(d) || d).value)},${yScale((prev.get(d) || d).rank)})`)
                    .attr("y", yScale.bandwidth() / 2)
                    .attr("x", -6)
                    .attr("dy", "-0.25em")
                    .text(d => d["影片名"])
                    .call(text => text.append("tspan")
                        .attr("fill-opacity", 0.7)
                        .attr("font-weight", "normal")
                        .attr("x", -6)
                        .attr("dy", "1.15em")),
                    update => update,
                    exit => exit.transition(transition).remove()
                    .attr("transform", d => `translate(${xScale((next.get(d) || d).value)},${yScale((next.get(d) || d).rank)})`)
                    .call(g => g.select("tspan").tween("text", d => textTween(d["单日票房(万)"], (next.get(d) || d).value)))
                )
                .call(bar => bar.transition(transition)
                    .attr("transform", d => `translate(${xScale(d["单日票房(万)"])},${yScale(d.rank)})`)
                    .call(g => g.select("tspan").tween("text", d => textTween((prev.get(d) || d).value, d["单日票房(万)"]))));
        }

        textTween = function (a, b) {
            const i = d3.interpolateNumber(a, b);
            return function (t) {
                this.textContent = formatNumber(i(t));
            };
        }

        axis = function (svg) {
            const g = svg.append("g")
                .attr("transform", `translate(0,${margin.top})`);

            const axis = d3.axisTop(xScale)
                .ticks(width / 160, tickFormat)
                .tickSizeOuter(0)
                .tickSizeInner(-barSize * (n + yScale.padding()));

            return (_, transition) => {
                g.transition(transition).call(axis);
                g.select(".tick:first-of-type text").remove();
                g.selectAll(".tick:not(:first-of-type) line").attr("stroke", "white");
                g.select(".domain").remove();
            };
        }

        ticker = function (svg) {
            const now = svg.append("text")
                .style("font", `bold ${barSize}px var(--sans-serif)`)
                .style("font-variant-numeric", "tabular-nums")
                .attr("text-anchor", "end")
                .attr("x", width - 6)
                .attr("y", margin.top + barSize * (n - 0.45))
                .attr("dy", "0.32em")
                .text(formatDate(keyframes[0][0]));

            return ([date], transition) => {
                transition.end().then(() => now.text(formatDate(date)));
            };
        }

        color = function () {
            const scale = d3.scaleOrdinal(d3.schemeTableau10);
            if (data.some(d => d.category !== undefined)) {
                const categoryByName = new Map(data.map(d => [d["影片名"], d.category]))
                scale.domain(categoryByName.values());
                return d => scale(categoryByName.get(d["影片名"]));
            }
            return d => scale(d["影片名"]);
        }

        chart = function () {
            replay;

            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height]);

            const updateBars = bars(svg);
            const updateAxis = axis(svg);
            const updateLabels = labels(svg);
            const updateTicker = ticker(svg);

            yield svg.node();

            for (const keyframe of keyframes) {
                const transition = svg.transition()
                    .duration(duration)
                    .ease(d3.easeLinear);

                // Extract the top bar’s value.
                xScale.domain([0, keyframe[1][0].value]);

                updateAxis(keyframe, transition);
                updateBars(keyframe, transition);
                updateLabels(keyframe, transition);
                updateTicker(keyframe, transition);
                
                invalidation.then(() => svg.interrupt());
                await transition.end();
            }
        }
    </script>
</body>

</html>